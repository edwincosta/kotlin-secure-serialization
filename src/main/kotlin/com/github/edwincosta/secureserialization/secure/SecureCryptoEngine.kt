package com.github.edwincosta.secureserialization.secure

import java.security.Key

/**
 * Interface for cryptographic operations used by [SecureSerializer].
 *
 * Implementations of this interface provide the actual encryption and decryption logic
 * for [SecureProperty] annotated fields. The interface abstracts the cryptographic
 * implementation details, allowing for different encryption algorithms and strategies.
 *
 * ## Implementation Considerations
 * - Use secure, industry-standard encryption algorithms (e.g., AES-256-GCM, ChaCha20-Poly1305)
 * - Generate cryptographically secure random IVs using [generateIv]
 * - Ensure IVs are unique for each encryption operation
 * - Handle exceptions appropriately (e.g., invalid keys, corrupted data)
 * - Consider authentication tags for authenticated encryption modes
 *
 * ## Recommended Encryption Algorithms
 * - **AES-256-GCM**: Authenticated encryption with associated data (AEAD)
 * - **AES-256-CBC**: With HMAC for authentication
 * - **ChaCha20-Poly1305**: Modern AEAD cipher
 *
 * ## Usage Example
 * ```kotlin
 * class AesGcmCryptoEngine : SecureCryptoEngine {
 *     override fun generateIv(): String {
 *         val iv = ByteArray(12) // GCM standard IV size
 *         SecureRandom().nextBytes(iv)
 *         return Base64.getEncoder().encodeToString(iv)
 *     }
 *
 *     override fun encrypt(plainText: String, key: Key, iv: String): String {
 *         val cipher = Cipher.getInstance("AES/GCM/NoPadding")
 *         val ivBytes = Base64.getDecoder().decode(iv)
 *         cipher.init(Cipher.ENCRYPT_MODE, key, GCMParameterSpec(128, ivBytes))
 *         val encrypted = cipher.doFinal(plainText.toByteArray())
 *         return Base64.getEncoder().encodeToString(encrypted)
 *     }
 *
 *     override fun decrypt(cipherText: String, key: Key, iv: String): String {
 *         val cipher = Cipher.getInstance("AES/GCM/NoPadding")
 *         val ivBytes = Base64.getDecoder().decode(iv)
 *         cipher.init(Cipher.DECRYPT_MODE, key, GCMParameterSpec(128, ivBytes))
 *         val decrypted = cipher.doFinal(Base64.getDecoder().decode(cipherText))
 *         return String(decrypted)
 *     }
 * }
 * ```
 *
 * @see SecureSerializer
 * @see SecureKeyProvider
 */
interface SecureCryptoEngine {
    /**
     * Generates a new initialization vector (IV) for encryption operations.
     *
     * The IV should be cryptographically random and unique for each encryption operation.
     * The generated IV is stored in the [Secure.e2eIv] property and used during decryption.
     *
     * @return A string representation of the generated IV.
     */
    fun generateIv(): String

    /**
     * Encrypts plain text using the provided key and initialization vector.
     *
     * @param plainText The plain text to encrypt.
     * @param key The encryption key provided by [SecureKeyProvider].
     * @param iv The initialization vector generated by [generateIv].
     * @return The encrypted cipher text.
     */
    fun encrypt(plainText: String, key: Key, iv: String): String

    /**
     * Decrypts cipher text using the provided key and initialization vector.
     *
     * @param cipherText The cipher text to decrypt.
     * @param key The decryption key provided by [SecureKeyProvider].
     * @param iv The initialization vector stored in [Secure.e2eIv].
     * @return The decrypted plain text.
     */
    fun decrypt(cipherText: String, key: Key, iv: String): String
}